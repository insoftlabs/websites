---
title: 'Customization'
description: 'Raddix is full customizable since it does not represent any Dom structure or imposes a style methodology.'
---

# Customization

Raddix is full customizable since it does not represent any Dom structure
or imposes a style methodology.

## Styling

Raddix is fully compatible with any style solution, providing total control.
It comes without predetermined style, it is up to you to add styles with the
style solution of your preference.

### Data Attributes

Hooks return data attributes in those components that have a state.
This is done by default so that the status of a component can be styling
by CSS or CSS-IN-JS.

<br />
For example, the Switch component has a checked status, this will include a <code>
  data-checked
</code> attribute every time the switch is checked. You can also deactivate this
option by changing the <code>dataAttr</code> prop to false.

```jsx
// switch.jsx
import { useSwitch } from '@raddix/switch';

const Switch = props => {
  const { switchProps } = useSwitch({
    dataAttr: false,
    ...props
  });

  return <button {...switchProps}></button>;
};
```

## Rendered

Raddix does not impose a specific Dom structure, allowing total control over the representation of its components.

### Element type

Each hook has a default <code>elementType</code> prop. This is
important since according to the selected <code>elementType</code>
Raddix will provide the necessary accessibility.

<br />
For example, the useSwitch hook assumes that it will be represented on an
HTML <code>{'<button>'}</code>, to be able to represent it on a different DOM
tag as a <code>{'<div>'}</code> should change the <code>elementType</code> prop.

```jsx
// switch.jsx
import { useSwitch } from '@raddix/switch';

const Switch = props => {
  const { switchProps } = useSwitch({
    elementType: 'div',
    ...props
  });

  return <div {...switchProps}></div>;
};
```
